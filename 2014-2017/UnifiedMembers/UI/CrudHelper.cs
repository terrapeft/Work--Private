using System;
using System.Collections;
using System.Collections.Generic;
using System.Configuration;
using System.Data;
using System.Data.Entity.Core.EntityClient;
using System.Data.SqlClient;
using System.Globalization;
using System.Linq;
using System.Web;
using System.Web.Caching;
using System.Web.UI;
using System.Web.UI.HtmlControls;
using System.Web.UI.WebControls;
using SharedLibrary;
using SharedLibrary.DynamicRadGrid.Columns;
using SharedLibrary.IPAddress;
using Telerik.Web.UI;
using Umbraco.Core;

namespace TradeDataUsers.UI
{
    /// <summary>
    /// Automates Insert/Update/Delete operations for Admin part of Umbraco backend.
    /// Based on Telerik RadGrid 2010.
    /// </summary>
    public class CrudHelper
    {
        private readonly RadGrid _grid;
        private readonly string _connectionString;

        public CrudHelper(RadGrid grid, string connectionStringName)
        {
            _grid = grid;
            _connectionString = GetConnectionString(connectionStringName);
        }

        /// <summary>
        /// Gathers data from editable columns and provides it as parameters for stored procedures to insert/update/delete.
        /// Key point is to use for a column's UniqueName the same string as for the stored procedure's parameter. 
        /// Special logic for GridTemplateColumns: 
        ///     - for list mode there are autogenerated columns with property ReadOnly=true
        ///     - for edit mode there is a template column where the UniqueNames property contains a list of autogenerated columns' unique names
        ///       devided with whitespaces
        ///     - parameter HasStoredProcParameters=true
        ///     - parameter Multiple="columnName" specifies a control which contains list of data, e.g. IPs
        ///     - multiple works for insert, edit is single.
        /// </summary>
        /// <param name="spName">Name of the sp.</param>
        /// <param name="row">The row.</param>
        /// <returns></returns>
        public DataTable CallStoredProcedure(string spName, GridEditableItem row)
        {
            var ds = new DataSet();

            using (var conn = new SqlConnection(_connectionString))
            using (var cmd = new SqlCommand(spName, conn))
            using (var da = new SqlDataAdapter(cmd))
            {
                cmd.CommandType = CommandType.StoredProcedure;
                cmd.CommandTimeout = 120;

                var parameters = new Dictionary<string, object>();

                // add PK values, if any
                if (row.ItemIndex >= 0) // skip on insert
                {
                    parameters = _grid.MasterTableView
                        .DataKeyNames
                        .ToDictionary(pk => pk, pk => row.OwnerTableView.DataKeyValues[row.ItemIndex][pk]);
                }

                // gather column values
                var cols = _grid.MasterTableView.Columns
                    .OfType<GridEditableColumn>()
                    .Where(c => !c.ReadOnly || c.UniqueName.Equals("appId"))
                    .ToList();

                cols.ForEach(c =>
                {
                    var ex = c as GridTemplateColumnEx;
                    if (ex != null)
                    {
                        var col = ex;
                        if (col.HasStoredProcParameters)
                        {
                            var @params = col.UniqueNames.Split(' ');
                            foreach (var p in @params.Where(p => !parameters.HasKey(p)))
                            {
                                // use it as multiple values container only in insert mode, otherwise - like single value
                                parameters.Add(p, GetValue(row, ex.UniqueName, p, row is GridEditFormInsertItem ? col.Multiple : null));
                            }
                        }
                    }
                    else
                    {
                        if (!parameters.HasKey(c.UniqueName))
                        {
                            parameters.Add(c.UniqueName, GetValue(row, c.UniqueName));
                        }
                    }
                });

                conn.Open();

                // get SP parameters
                SqlCommandBuilder.DeriveParameters(cmd);

                foreach (var pair in parameters)
                {
                    var pname = $"@{pair.Key}";

                    // add columns which have corresponding parameter in SP
                    if (cmd.Parameters.HasParameter(pname))
                    {
                        var prm = cmd.Parameters[pname];
                        var pval = pair.Value;

                        if (prm.DbType == DbType.DateTime || prm.DbType == DbType.DateTime2 || prm.DbType == DbType.Date)
                        {
                            if (pval == null)
                            {
                                pval = DBNull.Value;
                            }
                            else if (!(pval is DateTime))
                            {
                                pval = Convert.ToDateTime(pval, CultureInfo.InvariantCulture);
                            }
                        }

                        if (prm.SqlDbType == SqlDbType.Structured)
                        {
                            var parts = prm.TypeName.Split('.');
                            if (parts.Length == 3)
                            {
                                prm.TypeName = parts[1] + "." + parts[2];
                            }
                        }

                        prm.Value = pval;
                    }
                }

                da.Fill(ds);
            }

            return ds.Tables.Count > 0 ? ds.Tables[0] : null;
        }

        /// <summary>
        /// Loads the table with specified query.
        /// </summary>
        /// <param name="sqlQuery">The SQL query.</param>
        /// <param name="decryptPasswords">Open password key on database side before running query.</param>
        /// <returns></returns>
        public DataTable LoadTable(string sqlQuery, bool decryptPasswords = false/*, bool cacheData = false*/)
        {
            var dataTable = new DataTable();
            using (var conn = new SqlConnection(_connectionString))
            {
                conn.Open();

                if (decryptPasswords)
                {
                    var cmd = new SqlCommand
                    {
                        Connection = conn,
                        CommandText = "dbo.spOpenPasswordsKey",
                        CommandType = CommandType.StoredProcedure
                    };

                    cmd.ExecuteNonQuery();
                }

                var sqlDataAdapter = new SqlDataAdapter { SelectCommand = new SqlCommand(sqlQuery, conn) };
                sqlDataAdapter.Fill(dataTable);

                return dataTable;
            }
        }

        private string GetConnectionString(string connectionStringName)
        {
            var connectionString = ConfigurationManager.ConnectionStrings[connectionStringName].ConnectionString;
            var cns = string.Empty;

            try
            {
                cns = new EntityConnectionStringBuilder(connectionString).ProviderConnectionString;
            }
            catch { }

            if (string.IsNullOrWhiteSpace(cns))
                cns = new SqlConnectionStringBuilder(connectionString).ConnectionString;

            return cns;
        }

        /// <summary>
        /// Gets the value for autogenerated columns.
        /// </summary>
        /// <param name="row">The row.</param>
        /// <param name="column">The column.</param>
        /// <param name="controlId">The control identifier.</param>
        /// <param name="multipleId">The control with multiple values identifier.</param>
        /// <returns></returns>
        private dynamic GetValue(GridEditableItem row, string column, string controlId = null, string multipleId = null)
        {
            Control ctl = null;

            if (!string.IsNullOrEmpty(controlId))
            {
                ctl = row[column].FindControl(controlId);
            }
            else
            {
                ctl = row[column].Controls
                    .OfType<TextBox, HtmlTextArea, DropDownList, ListBox, CheckBox, RadDatePicker>()
                    .Cast<Control>()
                    .FirstOrDefault();
            }

            if (ctl is TextBox)
            {
                var value = TextBoxVal(ctl as TextBox).Null();

                if (ctl.ID.Equals(multipleId, StringComparison.OrdinalIgnoreCase) && value != null)
                {
                    var allValues = value.Split(IpListSplitter.Delimiters, StringSplitOptions.RemoveEmptyEntries);
                    return IpListSplitter.IsValidIp(allValues[0])
                        ? IpListSplitter.Split(value).ToTable("string")
                        : allValues.Select(v => v.Trim()).ToList().ToTable("string");
                }

                return value;
            }

            if (ctl is HtmlTextArea)
                return TextBoxVal(ctl as HtmlTextArea).Null();

            if (ctl is DropDownList)
                return DdlVal(ctl as DropDownList).Null();

            if (ctl is ListBox)
                return ListBoxVal(ctl as ListBox).ToTable("number");

            if (ctl is CheckBox)
                return CheckBoxVal(ctl as CheckBox);

            if (ctl is RadDatePicker)
                return DatePickerVal(ctl as RadDatePicker);

            return null;
        }

        private object DatePickerVal(RadDatePicker ctl)
        {
            return ((RadDatePicker)ctl).DbSelectedDate;
        }
        private string TextBoxVal(TextBox ctl)
        {
            return ctl?.Text;
        }

        private string TextBoxVal(HtmlTextArea ctl)
        {
            return ctl?.Value;
        }

        private string DdlVal(DropDownList ctl)
        {
            return ctl?.SelectedValue;
        }
        private List<string> ListBoxVal(ListBox ctl)
        {
            return ctl?.Items
                .Cast<ListItem>()
                .Select(li => li.Value)
                .ToList();
        }

        private bool CheckBoxVal(CheckBox ctl)
        {
            return ctl != null && ctl.Checked;
        }
    }
}